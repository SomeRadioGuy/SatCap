# -*- coding: utf-8 -*-
"""SatCap V1.3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DKp7N3G3Y-Zn3PVyApQyXfvCFfs-svHj
"""

import sys
import math
import numpy as np
import cv2
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel,
    QFileDialog, QTextEdit, QSplitter, QSizePolicy
)
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PIL import Image
from PIL.ImageQt import ImageQt
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from io import BytesIO

# -----------------------
# Utility functions
# -----------------------

def preprocess_image(pil_img, max_size=1200):
    """Convert to RGB numpy array and optionally downscale."""
    if pil_img.mode != "RGB":
        pil_img = pil_img.convert("RGB")
    if pil_img.width > max_size or pil_img.height > max_size:
        pil_img.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)
    img = np.array(pil_img)
    return img

def cloud_mask_from_rgb(img):
    """Improved cloud detection using HSV + brightness + morphology."""
    bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
    hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV).astype(np.float32) / 255.0
    h, s, v = hsv[..., 0], hsv[..., 1], hsv[..., 2]

    r = img[:, :, 0].astype(np.float32) / 255.0
    g = img[:, :, 1].astype(np.float32) / 255.0
    b = img[:, :, 2].astype(np.float32) / 255.0
    brightness = (r + g + b) / 3.0

    mask = (v > 0.55) & (s < 0.45) & (brightness > 0.45)

    mask_uint8 = (mask.astype(np.uint8) * 255)
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
    mask_clean = cv2.morphologyEx(mask_uint8, cv2.MORPH_CLOSE, kernel, iterations=1)
    mask_clean = cv2.morphologyEx(mask_clean, cv2.MORPH_OPEN, kernel, iterations=1)

    return mask_clean.astype(bool)

def region_properties(mask):
    """Connected components + properties."""
    mask_u8 = (mask.astype(np.uint8) * 255)
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask_u8, connectivity=8)
    regions = []
    for lbl in range(1, num_labels):
        x, y, w, h, area = stats[lbl]
        if area < 100:
            continue
        region_mask = (labels == lbl)
        ys, xs = np.where(region_mask)
        xmin, xmax = xs.min(), xs.max()
        ymin, ymax = ys.min(), ys.max()
        cx, cy = centroids[lbl]

        coords = np.column_stack([xs.astype(np.float32) - cx, ys.astype(np.float32) - cy])
        if coords.shape[0] >= 3:
            cov = np.cov(coords.T)
            eigvals, eigvecs = np.linalg.eig(cov)
            order = np.argsort(eigvals)[::-1]
            eigvals = eigvals[order]
            eigvecs = eigvecs[:, order]
            major_len = math.sqrt(eigvals[0]) * 4.0
            minor_len = math.sqrt(eigvals[1]) * 4.0
            vx, vy = eigvecs[0, 0], eigvecs[1, 0]
            orient_rad = math.atan2(vy, vx)
            orientation_deg = math.degrees(orient_rad)
        else:
            major_len = w
            minor_len = h
            orientation_deg = 0.0

        hull = cv2.convexHull(np.column_stack((xs, ys)).astype(np.int32))
        hull_area = cv2.contourArea(hull) if hull is not None and hull.size > 0 else area
        solidity = float(area) / float(hull_area) if hull_area > 0 else 1.0

        mean_brightness = float(np.mean((img[region_mask, 0].astype(np.float32) +
                                         img[region_mask, 1].astype(np.float32) +
                                         img[region_mask, 2].astype(np.float32)) / 3.0)) / 255.0
        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        lap = cv2.Laplacian(gray, cv2.CV_64F)
        texture = float(np.var(lap[region_mask]))

        regions.append({
            'label': lbl,
            'bbox': (xmin, ymin, xmax, ymax),
            'area': int(area),
            'centroid': (float(cx), float(cy)),
            'orientation': orientation_deg,
            'major_len': float(major_len),
            'minor_len': float(minor_len),
            'solidity': float(solidity),
            'mean_brightness': mean_brightness,
            'texture': texture,
            'mask': region_mask
        })
    return regions

def estimate_wind_from_region(region, bias_east=True):
    orient = region['orientation']
    wind_dir = (orient + 90.0) % 360.0
    if bias_east and 160 <= wind_dir <= 200:
        wind_dir = 110.0
    area_factor = math.log10(max(region['area'], 100))
    texture_factor = math.log1p(region['texture'])
    aspect = max(region['major_len'] / max(region['minor_len'], 1.0), 1.0)
    speed = 5.0 + 6.0 * area_factor + 4.0 * texture_factor + 2.0 * (aspect - 1.0)
    speed = float(max(5.0, min(speed, 90.0)))
    return wind_dir, speed

def classify_region(region):
    area = region['area']
    texture = region['texture']
    mean_brightness = region['mean_brightness']
    solidity = region['solidity']
    if area > 15000 and texture > 1000.0 and mean_brightness > 0.6:
        return 'storm'
    if texture > 300.0 and area > 2000:
        return 'convective'
    if solidity > 0.85 and area > 500:
        return 'stratiform'
    return 'small'

# -----------------------
# Worker thread
# -----------------------

class Worker(QThread):
    finished = pyqtSignal(object, object, object)  # (QPixmap, summary text, overlay_bytes)

    def __init__(self, img_path):
        super().__init__()
        self.img_path = img_path

    def run(self):
        try:
            global img
            pil_img = Image.open(self.img_path)
            img = preprocess_image(pil_img, max_size=1000)
            height, width = img.shape[:2]

            mask = cloud_mask_from_rgb(img)
            regions = region_properties(mask)

            processed_regions = []
            max_area = 0
            for reg in regions:
                if reg['area'] < 300:
                    continue
                wind_dir, wind_speed = estimate_wind_from_region(reg)
                cls = classify_region(reg)
                reg['wind_dir'] = wind_dir
                reg['wind_speed'] = wind_speed
                reg['class'] = cls
                processed_regions.append(reg)
                if reg['area'] > max_area:
                    max_area = reg['area']

            extent = [-30, 60, 30, 75]
            fig, ax = plt.subplots(figsize=(10, 7))
            ax.imshow(img, origin='upper', extent=extent)

            class_color = {
                'storm': 'red',
                'convective': 'orange',
                'stratiform': 'cyan',
                'small': 'yellow'
            }

            summary_lines = []
            summary_lines.append(f"Loaded image size: {width} x {height} px")
            summary_lines.append(f"Detected cloud regions (after filtering): {len(processed_regions)}")
            summary_lines.append(f"Largest cloud region area: {max_area} pixels\n")
            summary_lines.append(f"{'Class':<12}{'BBox':<28}{'Centroid':<20}{'Dir°':<8}{'Speed(km/h)':<14}{'Area(px²)':<10}")
            summary_lines.append("-"*92)

            for reg in processed_regions:
                xmin, ymin, xmax, ymax = reg['bbox']
                color = class_color.get(reg['class'], 'white')
                lon_min = extent[0] + (xmin / width) * (extent[1] - extent[0])
                lon_max = extent[0] + (xmax / width) * (extent[1] - extent[0])
                lat_max = extent[3] - (ymin / height) * (extent[3] - extent[2])
                lat_min = extent[3] - (ymax / height) * (extent[3] - extent[2])
                rect = patches.Rectangle((lon_min, lat_min), lon_max - lon_min, lat_max - lat_min,
                                         linewidth=2, edgecolor=color, facecolor='none')
                ax.add_patch(rect)

                cx_pix, cy_pix = reg['centroid']
                cx_lon = extent[0] + (cx_pix / width) * (extent[1] - extent[0])
                cy_lat = extent[3] - (cy_pix / height) * (extent[3] - extent[2])
                wd = reg['wind_dir']
                ws = reg['wind_speed']
                arrow_len = (ws / 30.0) * 3.0
                dx = arrow_len * math.cos(math.radians(wd))
                dy = arrow_len * math.sin(math.radians(wd))
                ax.arrow(cx_lon, cy_lat, dx, dy, head_width=0.6, head_length=0.6,
                         fc=color, ec=color, linewidth=2)
                proj_rect = patches.Rectangle((lon_min + dx, lat_min + dy), lon_max - lon_min, lat_max - lat_min,
                                              linewidth=1, edgecolor=color, facecolor=color, alpha=0.15)
                ax.add_patch(proj_rect)

                summary_lines.append(f"{reg['class']:<12}"
                                     f"({xmin},{ymin},{xmax},{ymax})".ljust(28) +
                                     f"({reg['centroid'][0]:.1f},{reg['centroid'][1]:.1f})".ljust(20) +
                                     f"{wd:>6.1f}".ljust(8) +
                                     f"{ws:>10.1f}".ljust(14) +
                                     f"{reg['area']:>8}")

            legend_text = "Legend: red=storm, orange=convective, cyan=stratiform, yellow=small clouds"
            ax.text(0.01, 0.01, legend_text, transform=ax.transAxes, fontsize=9,
                    bbox=dict(facecolor='white', alpha=0.6, edgecolor='none'))

            ax.set_xlabel("Longitude")
            ax.set_ylabel("Latitude")
            ax.set_title("Weather Projection Overlay (heuristic)")
            plt.tight_layout()

            buf = BytesIO()
            plt.savefig(buf, format='png', dpi=150)
            buf.seek(0)
            pil_overlay = Image.open(buf).convert("RGBA")
            qimg = ImageQt(pil_overlay)
            pixmap = QPixmap.fromImage(qimg)

            self.finished.emit(pixmap, "\n".join(summary_lines), buf.getvalue())

        except Exception as e:
            self.finished.emit(None, f"Error during processing:\n{e}", None)

# -----------------------
# GUI
# -----------------------

class WeatherApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Offline Satellite Weather Projection")
        self.resize(1200, 800)

        layout = QVBoxLayout(self)

        self.open_btn = QPushButton("Open LRPT/APT PNG Image")
        self.open_btn.clicked.connect(self.open_image)
        layout.addWidget(self.open_btn)

        self.save_btn = QPushButton("Save Projection Image")
        self.save_btn.clicked.connect(self.save_image)
        self.save_btn.setEnabled(False)
        layout.addWidget(self.save_btn)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        layout.addWidget(splitter)

        self.image_label = QLabel("Load an image to begin")
        self.image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        splitter.addWidget(self.image_label)

        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        splitter.addWidget(self.summary_text)

        self.worker = None
        self.overlay_bytes = None

    def open_image(self):
        path, _ = QFileDialog.getOpenFileName(self, "Open LRPT/APT PNG Image", "", "PNG Files (*.png);;All Files (*)")
        if not path:
            return
        self.summary_text.setPlainText("Processing image, please wait...")
        self.open_btn.setEnabled(False)
        self.save_btn.setEnabled(False)
        self.worker = Worker(path)
        self.worker.finished.connect(self.processing_done)
        self.worker.start()

    def processing_done(self, pixmap, summary, overlay_bytes):
        self.open_btn.setEnabled(True)
        if pixmap:
            self.image_label.setPixmap(pixmap.scaled(
                self.image_label.width(), self.image_label.height(),
                Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation))
            self.overlay_bytes = overlay_bytes
            self.save_btn.setEnabled(True)
        else:
            self.image_label.setText("Failed to process image.")
        self.summary_text.setPlainText(summary)

    def save_image(self):
        if not self.overlay_bytes:
            return
        path, _ = QFileDialog.getSaveFileName(self, "Save Projection Image", "", "PNG Files (*.png)")
        if path:
            with open(path, "wb") as f:
                f.write(self.overlay_bytes)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = WeatherApp()
    win.show()
    sys.exit(app.exec())